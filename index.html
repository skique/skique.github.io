<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>taoyouyou的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="一枚嗜好太多，能力太小的普通程序媛，">
<meta name="keywords" content="前端,js,jquery,javascript,html5,vue,开发者,程序猿,程序媛,极客,编程,代码,开源,IT网站,Developer,Programmer,Coder,Geek,html,css,css3,用户体验,视觉设计,摄影摄像">
<meta property="og:type" content="website">
<meta property="og:title" content="taoyouyou的博客">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="taoyouyou的博客">
<meta property="og:description" content="一枚嗜好太多，能力太小的普通程序媛，">
<meta property="og:locale" content="zh-cn">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="taoyouyou的博客">
<meta name="twitter:description" content="一枚嗜好太多，能力太小的普通程序媛，">
  
    <link rel="alternate" href="/atom.xml" title="taoyouyou的博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">taoyouyou的博客</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">每一个不曾起舞的日子都是对生命的辜负</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Buscar"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-如何用hexo搭出自己的博客系统" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/19/如何用hexo搭出自己的博客系统/" class="article-date">
  <time datetime="2020-03-19T06:07:19.000Z" itemprop="datePublished">2020-03-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/19/如何用hexo搭出自己的博客系统/">如何用hexo搭出自己的博客系统</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>关于hexo以及安装hexo可以详见<a href="https://hexo.io/zh-cn/docs/index.html" target="_blank" rel="noopener">官方文档</a></p>
<h3 id="关于hexo"><a href="#关于hexo" class="headerlink" title="关于hexo"></a>关于hexo</h3><p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>安装之前需要确保安装了node(Node.js 版本需不低于 8.10，建议使用 Node.js 10.0 及以上版本)和git,所有必备的应用程序安装完成后，即可使用 npm 安装 Hexo。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure></p>
<h3 id="建站"><a href="#建站" class="headerlink" title="建站"></a>建站</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo init &lt;folder&gt;  // hexo初始化项目</span><br><span class="line">cd &lt;folder&gt;         // 进入新建的文件夹</span><br><span class="line">npm install         // 安装依赖</span><br></pre></td></tr></table></figure>
<p>新建完成后指定的文件夹目录如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── _config.yml     // 网站配置文件，配置字段可详见[官网配置详解](https://hexo.io/zh-cn/docs/configuration)</span><br><span class="line">├── package.json</span><br><span class="line">├── scaffolds       // 模版 文件夹。当您新建文章时，Hexo 会根据 scaffold 来建立文件</span><br><span class="line">├── source          // 资源文件夹是存放用户资源的地方。Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件会被拷贝过去。</span><br><span class="line">|   ├── _drafts</span><br><span class="line">|   └── _posts</span><br><span class="line">└── themes          // 主题 文件夹。Hexo 会根据主题来生成静态页面</span><br></pre></td></tr></table></figure></p>
<h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><p>Hexo 3.0 把服务器独立成了个别模块，您必须先安装 hexo-server 才能使用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-server --save</span><br></pre></td></tr></table></figure></p>
<p>安装完成后，输入以下命令以启动服务器，您的网站会在 <ip>:<port> 下启动。在服务器启动期间，Hexo 会监视文件变动并自动更新，您无须重启服务器。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo server -p 5000</span><br></pre></td></tr></table></figure></port></ip></p>
<p>开启命令后可以在本地预览</p>
<h3 id="写作"><a href="#写作" class="headerlink" title="写作"></a>写作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new [layout] &lt;title&gt;    // 发布一篇新的文章或者新的页面</span><br></pre></td></tr></table></figure>
<p>Layout:<br>Hexo 有三种默认布局：post、page 和 draft。在创建者三种不同类型的文件时，它们将会被保存到不同的路径；而您自定义的其他布局和 post 相同，都将储存到 source/_posts 文件夹。<br>Title:<br>Hexo 默认以标题做为文件名称，但您可编辑 new_post_name 参数来改变默认的文件名称，举例来说，设为 :year-:month-:day-:title.md 可让您更方便的通过日期来管理文章。</p>
<p>通过命令新建一篇文章后，会在 source 文件夹内响应的布局（_post）文件夹下生成以.md后缀结尾的文章，可以直接在这里通过markdown语言完成一篇文章</p>
<h3 id="生成"><a href="#生成" class="headerlink" title="生成"></a>生成</h3><p>hexo中使用generate命令可以生成静态文件快速而且简单。 或者可以加上watch参数，在监听文件变动的同时生成静态文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo generate --watch</span><br></pre></td></tr></table></figure></p>
<p>完成后部署<br>您可执行下列的其中一个命令，让 Hexo 在生成完毕后自动部署网站，两个命令的作用是相同的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo g -d</span><br><span class="line">hexo d -g</span><br></pre></td></tr></table></figure></p>
<h3 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h3><p>通过generate命令编译生成public静态文件夹以后，可以通过github pages服务，可以为您的静态文件托管一个web站点。<br>Git Pages 一个支持Jekyll、Hugo、Hexo静态网站的服务。因为网络的原因，这里以国内git服务商gitee为例简单介绍一个如何托管个人的web站点，生成一个能用于预览的网址。首先需要将生成的public项目先托管在gitee中。   </p>
<p>Hexo 提供了快速方便的一键部署功能，让您只需一条命令就能将网站部署到服务器上。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo deploy</span><br></pre></td></tr></table></figure></p>
<p>在开始之前，您必须先在 _config.yml 中修改参数，一个正确的部署配置中至少要有 type 参数，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br></pre></td></tr></table></figure></p>
<p>您可同时使用多个 deployer，Hexo 会依照顺序执行每个 deployer。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">- type: git</span><br><span class="line">  repo:</span><br><span class="line">- type: heroku</span><br><span class="line">  repo:</span><br></pre></td></tr></table></figure></p>
<p>在配置好_config.yml中配置好远程仓库地址后该不能直接用deploy命令部署，需要先安装<a href="https://github.com/hexojs/hexo-deployer-git" target="_blank" rel="noopener">hexo-deployer-git</a>插件，git插件是专门用于hexo站点部署的Git部署插件，所以正确的步骤是<br>1，执行安装命令安装hexo-deployer-git<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure></p>
<p>2，修改配置文件，为站点配置远程仓库地址<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: &lt;repository url&gt; #https://bitbucket.org/JohnSmith/johnsmith.bitbucket.io</span><br><span class="line">  branch: [branch]</span><br><span class="line">  message: [message]</span><br></pre></td></tr></table></figure></p>
<p>3， 生成站点文件并推送至远程库<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g -d   // 让 Hexo 在生成完毕后自动部署网站</span><br></pre></td></tr></table></figure></p>
<p>当执行 hexo deploy 时，Hexo 会将 public 目录中的文件和目录推送至 _config.yml 中指定的远端仓库和分支中，并且完全覆盖该分支下的已有内容。   </p>
<p>4，在提供github或者gitee上有了托管的public目录文件的仓库，在仓库的服务页面找到Pages服务<br><img src="https://gitee.com/taoyouyou/taoyouyou/raw/master/assets/photos/git-pages.png" alt=""><br>需要注意的是部署的跟路径下必须存在index.html作用站点访问的入口，<br>这里为了让站点路径以 https://&lt;用户名&gt;.gitee.io 的形式访问，最好把你的远程仓库的名字以你的用户名命名。<br>点开Git Pages服务后首先会要求你填写部署的分支，以及部署的目录，并且明确提示如果目录为空的话就会部署整个仓库<br>点击确定按钮后会为这个分支以及目录开始静态网站服务，通过 https://&lt;用户名&gt;.gitee.io 即可以访问你的博客了</p>
<h3 id="基本命令行"><a href="#基本命令行" class="headerlink" title="基本命令行"></a>基本命令行</h3><ul>
<li><p>发布一篇文章<br>hexo new post “myFirstPost”  </p>
</li>
<li><p>编辑文章<br>vi myFirstPost.md</p>
</li>
<li><p>开启本地服务<br>hexo server -p 5000<br>简写<br>hexo s  // 默认端口为3000   </p>
</li>
<li><p>使用 Hexo 生成静态文件<br>hexo generate<br>或者<br>hexo g</p>
</li>
<li><p>完成后部署<br>hexo generate –deploy<br>hexo deploy –generate<br>简写<br>hexo g -d<br>hexo d -g   </p>
</li>
</ul>
<h3 id="自定义主题"><a href="#自定义主题" class="headerlink" title="自定义主题"></a>自定义主题</h3><p> 如果您对hexo默认的主题并不满意，您可以使用其他人写好的hexo主题<br> 以下是github星标数比较高的几款hexo主题</p>
<ol>
<li><a href="https://www.imys.net/" target="_blank" rel="noopener">Indigo</a>，项目地址：<a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank" rel="noopener">https://github.com/yscoder/hexo-theme-indigo</a><!-- ![](https://img-blog.csdnimg.cn/20190816091540982.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pnZDgyNjIzNzcxMA==,size_16,color_FFFFFF,t_70) --></li>
<li><a href="https://jerryc.me/" target="_blank" rel="noopener">Butterfly</a>，项目地址：<a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener">https://github.com/jerryc127/hexo-theme-butterfly</a><!-- ![](https://img-blog.csdnimg.cn/20190816091627682.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pnZDgyNjIzNzcxMA==,size_16,color_FFFFFF,t_70) --></li>
<li><a href="https://molunerfinn.com" target="_blank" rel="noopener">Melody</a>，项目地址：<a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener">https://github.com/Molunerfinn/hexo-theme-melody</a><!-- ![](https://img-blog.csdnimg.cn/20190816091738576.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pnZDgyNjIzNzcxMA==,size_16,color_FFFFFF,t_70) --></li>
<li><a href="https://nexmoe.com/" target="_blank" rel="noopener">Nexmoe</a>，项目地址：<a href="https://github.com/nexmoe/hexo-theme-nexmoe" target="_blank" rel="noopener">https://github.com/nexmoe/hexo-theme-nexmoe</a><!-- ![](https://img-blog.csdnimg.cn/20190816091825224.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pnZDgyNjIzNzcxMA==,size_16,color_FFFFFF,t_70) --></li>
<li><a href="https://esappear.github.io/clover/" target="_blank" rel="noopener">Clover</a>，项目地址：<a href="https://github.com/esappear/hexo-theme-clover" target="_blank" rel="noopener">https://github.com/esappear/hexo-theme-clover</a><!-- ![](https://img-blog.csdnimg.cn/20190816091859750.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pnZDgyNjIzNzcxMA==,size_16,color_FFFFFF,t_70) --></li>
<li><a href="http://litten.me/" target="_blank" rel="noopener">Yilia</a>，项目地址：<a href="https://github.com/litten/hexo-theme-yilia" target="_blank" rel="noopener">https://github.com/litten/hexo-theme-yilia</a><!-- ![](https://pic1.zhimg.com/80/57291a4ee84ce548460d5d226a52a2d8_1440w.jpg) -->
</li>
</ol>
<p>如果您对于博客的主题有自己想法，那么您可以自定义生成一个全新的博客主题。 创建自定义的主题详见官方文档<a href="https://hexo.io/zh-cn/docs/themes" target="_blank" rel="noopener">主题</a></p>
<p>在这里我的博客使用的主题是上述最后一个主题Yilia, 使用第三方开源的主题的很简单，</p>
<ol>
<li>只需要将该主题clone在本地，放入hexo项目目录中的theme文件夹中。</li>
<li>然后在在根目录的_config.yml的theme中填入该主题对应的名字</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/03/19/如何用hexo搭出自己的博客系统/" data-id="ck7yku2rm000xo5yrmn92hyxr" class="article-share-link">Compartir</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/git/">git</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hexo/">hexo</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/web/">web</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-如何使用ESLint-Prettier来统一我们的前端代码风格" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/06/21/如何使用ESLint-Prettier来统一我们的前端代码风格/" class="article-date">
  <time datetime="2019-06-21T01:57:04.000Z" itemprop="datePublished">2019-06-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/06/21/如何使用ESLint-Prettier来统一我们的前端代码风格/">如何使用ESLint + Prettier来统一我们的前端代码风格</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>你曾经是否也会因为eslint在终端提示的报错而抓狂，作为一个强迫症患者不能看见终端有一行红色字体的代码报错。虽然eslint语法报错并不能影响程序的正常运行，但是作为一个有轻微代码洁癖的人来说，养成良好的代码编写风格也是一件非常重要的技能。关于代码风格实际上并没有一个确切的可以依靠的准绳，不同的人有不同的规范。在自己个人的项目中可以确定出自己最适应的一种代码风格。在团队协作的项目中，就必须通过少数服从多数来确定一种合适的书写规范，通过工具统一风格。    </p>
<p>本文将介绍，如何使用ESLint + Prettier来统一我们的前端代码风格。   </p>
<p>首先，对应ESLint大多都很熟悉，用来进行代码的校验，js作为一门灵活的弱类型语言，代码风格千奇百怪，一千个人写js就有一千种写法。虽然js没有官方推荐的代码规范，不过社区有些比较热门的代码规范，比如standardjs、airbnb。使用ESLint配合这些规范，能够检测出代码中的潜在问题，提高代码质量，但是并不能完全统一代码风格，因为这些代码规范的重点并不在代码风格上（虽然有一些限制）。</p>
<p>Prettier 是一个漂亮代码格式工具。prettier 通过将JavaScript解析为AST来去除原来的代码样式，并且将其按照一致的格式的方式输出。只要代码的内容是一样的，那么输出的代码就将会是一致的。 prettier只关注格式化，并不具有lint检查语法等能力，所以开始大家可能会经常碰到lint搭配prettier会出现冲突。而且prettier独断自行一套格式化风格，虽然提供配置，也只是配置少量的关键属性，能在一定程度上保证的代码的风格统一，而且使用门槛极低， 关键的他的风格并不丑，更容易让大家接受。<br>同时，prettier支持我们大前端目前大部分语言处理，包括JavaScript · Flow · TypeScript · CSS · SCSS · Less · JSX · Vue · GraphQL · JSON · Markdown，唯一的遗憾是，暂时还不能格式化vue模版文件中template部分。</p>
<h2 id="ESLint-与-Prettier配合使用"><a href="#ESLint-与-Prettier配合使用" class="headerlink" title="ESLint 与 Prettier配合使用"></a>ESLint 与 Prettier配合使用</h2><p>首先肯定是需要安装prettier，并且你的项目中已经使用了ESLint，有eslintrc.js配置文件。<br><code>npm i -D prettier</code></p>
<p>配合ESLint检测代码风格<br>安装插件<br><code>npm i -D eslint-plugin-prettier</code>   </p>
<p>eslint-plugin-prettier插件会调用prettier对你的代码风格进行检查，其原理是先使用prettier对你的代码进行格式化，然后与格式化之前的代码进行对比，如果过出现了不一致，这个地方就会被prettier进行标记。</p>
<p>接下来，我们需要在eslint配置文件的rules中添加，”prettier/prettier”: “error”，表示被prettier标记的地方抛出错误信息。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//.eslintrc.js</span><br><span class="line">&#123;</span><br><span class="line">  &quot;plugins&quot;: [&quot;prettier&quot;],</span><br><span class="line">  &quot;rules&quot;: &#123;</span><br><span class="line">    &quot;prettier/prettier&quot;: &quot;error&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上文提到prettier只关注格式化，并不具有lint检查语法等能力，所以开始大家可能会经常碰到lint搭配prettier会出现冲突,这里我们需要来讲一下如果存在冲突怎么办<br><code>npm i -D eslint-config-prettier</code><br>通过使用eslint-config-prettier配置，能够关闭一些不必要的或者是与prettier冲突的lint选项。这样我们就不会看到一些error同时出现两次。使用的时候需要确保，这个配置在extends的最后一项。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//.eslintrc.js</span><br><span class="line">&#123;</span><br><span class="line">  extends: [</span><br><span class="line">    &apos;@vue/airbnb&apos;, //使用standard做代码规范</span><br><span class="line">    &quot;prettier&quot;,</span><br><span class="line">  ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果你同时使用了上述的两种配置，那么你可以通过如下方式，简化你的配置。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;extends&quot;: [&quot;plugin:prettier/recommended&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最后贴一下我们项目中的完整配置，是在vue-cli生成的代码基础上修改的，并且使用airbnb做代码规范：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  root: true,</span><br><span class="line">  env: &#123;</span><br><span class="line">    node: true,</span><br><span class="line">  &#125;,</span><br><span class="line">  extends: [</span><br><span class="line">    &apos;plugin:vue/essential&apos;,</span><br><span class="line">    &apos;@vue/airbnb&apos;,</span><br><span class="line">    &quot;plugin:prettier/recommended&quot;,</span><br><span class="line">  ],</span><br><span class="line">  plugins: [&quot;prettier&quot;],</span><br><span class="line">  rules: &#123;</span><br><span class="line">    &apos;comma-dangle&apos;: &apos;off&apos;,</span><br><span class="line">    &apos;linebreak-style&apos;: &apos;off&apos;,</span><br><span class="line">    &apos;consistent-return&apos;: &apos;off&apos;,</span><br><span class="line">    &apos;no-param-reassign&apos;: &apos;off&apos;,</span><br><span class="line">    &apos;max-len&apos;: &apos;off&apos;,</span><br><span class="line">    &apos;vue/no-use-v-if-with-v-for&apos;: &apos;off&apos;,</span><br><span class="line">    &apos;vue/require-valid-default-prop&apos;: &apos;off&apos;,</span><br><span class="line">    &quot;prettier/prettier&quot;: &quot;error&quot;,</span><br><span class="line">    &apos;no-console&apos;: process.env.NODE_ENV === &apos;production&apos; ? &apos;error&apos; : &apos;off&apos;,</span><br><span class="line">    &apos;no-debugger&apos;: process.env.NODE_ENV === &apos;production&apos; ? &apos;error&apos; : &apos;off&apos;,</span><br><span class="line">  &#125;,</span><br><span class="line">  parserOptions: &#123;</span><br><span class="line">    parser: &apos;babel-eslint&apos;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="如何对Prettier进行配置"><a href="#如何对Prettier进行配置" class="headerlink" title="如何对Prettier进行配置"></a>如何对Prettier进行配置</h2><p>一共有三种方式支持对Prettier进行配置：</p>
<ol>
<li>根目录创建.prettierrc文件，能够写入YML、JSON的配置格式，并且支持.yaml/.yml/.json/.js后缀；</li>
<li>根目录创建.prettier.config.js文件，并对外export一个对象；</li>
<li>在package.json中新建prettier属性。   </li>
</ol>
<p>下面我们使用prettierrc.js的方式对prettier进行配置，同时讲解下各个配置的作用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  &quot;printWidth&quot;: 80, //一行的字符数，如果超过会进行换行，默认为80</span><br><span class="line">  &quot;tabWidth&quot;: 2, //一个tab代表几个空格数，默认为80</span><br><span class="line">  &quot;useTabs&quot;: false, //是否使用tab进行缩进，默认为false，表示用空格进行缩减</span><br><span class="line">  &quot;singleQuote&quot;: false, //字符串是否使用单引号，默认为false，使用双引号</span><br><span class="line">  &quot;semi&quot;: true, //行位是否使用分号，默认为true</span><br><span class="line">  &quot;trailingComma&quot;: &quot;none&quot;, //是否使用尾逗号，有三个可选值&quot;&lt;none|es5|all&gt;&quot;</span><br><span class="line">  &quot;bracketSpacing&quot;: true, //对象大括号直接是否有空格，默认为true，效果：&#123; foo: bar &#125;</span><br><span class="line">  &quot;parser&quot;: &quot;babylon&quot; //代码的解析引擎，默认为babylon，与babel相同。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>配置大概列出了这些，还有一些其他配置可以在<a href="">官方文档</a>进行查阅。</p>
<p>注意一点，parser的配置项官网列出了如下可选项：</p>
<ul>
<li>babylon</li>
<li>flow</li>
<li>typescript Since v1.4.0</li>
<li>postcss Since v1.4.0</li>
<li>json Since v1.5.0</li>
<li>graphql Since v1.5.0</li>
<li>markdown Since v1.8.0<br>但是如果你使用了vue的单文件组件形式，记得将parser配置为vue，目前官方文档没有列出来。当然如果你自己写过AST的解析器，也可以用你自己的写的parser: require(“./my-parser”)。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/06/21/如何使用ESLint-Prettier来统一我们的前端代码风格/" data-id="ck7yku2rl000wo5yr9gh7x6mc" class="article-share-link">Compartir</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-极简白话金融学" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/05/15/极简白话金融学/" class="article-date">
  <time datetime="2019-05-15T09:01:49.000Z" itemprop="datePublished">2019-05-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/05/15/极简白话金融学/">极简白话金融学</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="微观金融学——商学院的金融学"><a href="#微观金融学——商学院的金融学" class="headerlink" title="微观金融学——商学院的金融学"></a>微观金融学——商学院的金融学</h2><p>微观金融学就是研究人们如何在不确定的环境下进行资源跨期配置的学科，通俗地说，就是研究个体的金融决策的学问。这也就是我们市场上最热门的学问——公开上市、兼并收购、私募、股票涨跌、期货期权、资产证券化、基金、债券，高频交易、量化交易，甚至现在热炒的互联网金融……莫不属于这个领域。可以说，凡是和我们个体财富相关的投融资决策和背景都属于微观金融学的研究范畴，不确定环境和跨期资源配置因此成了这个学科最典型的标志。与此相适应，对于风险、风险收益、对风险证券的定价、公司投融资决策，以及影响这些因素的市场结构和制度安排成为其主要内容。</p>
<p>在传统的西方学科语系中，现代金融学一般指的就是微观金融学。根据研究对象的不同，我们将其大概分为“公司金融”和“投资学”两部分内容。</p>
<ul>
<li>公司金融是从企业角度出发，研究企业筹融资（比如上市、发行债券、增发、私有化等），企业发展扩张（比如兼并收购、分拆、寻找项目、分红决策等），以及企业治理（比如股东权利、董事会、管理层薪酬激励等）。</li>
<li>投资学则是从投资者角度出发，研究证券的合理定价（比如依据股票/债券/期货的风险程度，判断现在价格是被高估或者低估），进行资产管理（比如在不同的资产种类中，寻找最优化的资产组合），以及与资产管理相关的市场结构和制度安排。</li>
</ul>
<h3 id="历史大纪事："><a href="#历史大纪事：" class="headerlink" title="历史大纪事："></a>历史大纪事：</h3><ol>
<li><p>1952年，马科维茨（Markowitz）的年轻人提出了 <strong>投资组合理论</strong>。被称为“现代金融学的大爆炸”：将收益率视为一个数学上的随机变量。证券的期望收益则是该随机变量的数学期望（均值）；而风险则可以用该随机变量的方差来表示。将各证券的投资比例设定为变量，将这个问题转化为设计一个数学规划，如何使得证券组合的收益最大、风险最小。对于每一固定收益率求最小方差，或者对于每一个固定的方差求最大收益率，这个多元方程的解可以决定一条曲线。这条曲线上的每个点都对应着最优投资组合（给定风险水平下，收益率最大的组合），这条线的名字就叫“有效前沿”。对于投资者而言，不存在比有效前沿上更优的组合。这样一来，投资者面临的决策就被简化了许多。换句话说，所有投资者都可以根据自己的风险偏好在这个“有效前沿”上寻找自己的最优策略。 由于这是一个纯技术性的理论，完全脱离了经典经济学的一般均衡的框架，因而被视为异端。著名的经济学家米尔顿·弗里德曼教授（Milton Friedman）指责说：“这可不是经济学。”————第一次华尔街革命</p>
</li>
<li><p>20世纪60年代, 马科维茨的学生威廉·夏普（W.Sharpe），进一步在一般均衡的框架下，假定证券市场中所有投资人都有相同的初始偏好，以“风险—收益”函数来决策，从而推导出一个单个证券（投资组合）的期望受益率与相对风险程度间的关系式, 所谓“相对风险程度”，是指该证券（证券组合）和市场组合之间的联动性（术语叫“协方差”）。在理论的模型里，这个“市场组合”可以在一系列严格的假设下被推算出来。而在一般现实世界中，我们常常会用市场指数（比如道琼斯指数、上证指数、日经指数等）来近似表示这个市场组合。这就是金融学里最著名的 <strong>资产定价模型</strong></p>
</li>
<li><p>20世纪60年代中期到70年代, 尤金·法玛（Eugene Fama）提出了 <strong>有效市场假说</strong>。所谓市场有效性是指市场价格能否充分反映市场价格。</p>
</li>
<li><p>1979年丹石尔·卡尼曼（Daniel Kahneman）和阿莫斯·特维尔斯基（Amas Tversky）通过一系列的实验证明，长期以来主宰金融经济学的“理性人”的假定常常受到约束。人类的决策过程往往受到个人偏好、社会规范、观念习惯的影响，因而导致“理性预期”出现系统性的偏差。除此之外，卡尼曼和特维尔斯基还发现了人类在决策中会体现出如“损失规避”“框架效应”等系统性的特征，这些特征构成了“预期理论”的基础。以此为起点，金融学家们开始探讨“非理性预期”下的资产定价和投融资决策行为——<strong>行为金融学</strong>因此在20世纪80年代后蓬勃发展。</p>
</li>
</ol>
<ol>
<li><p>1956年，默顿·米勒和莫迪利安尼（Modigliani）于1956年提出了另一个划时代的理论——<strong>资本结构理论</strong>：米勒和莫迪利安尼首次阐述了无套利假设。无套利假设是指在一个完善的金融市场里，不存在确定的高卖低买的套利机会。米勒和莫迪利安尼证明了理想市场条件下，公司价值与财务政策无关。MM定理的精妙之处在于，它设定了一个“理想市场”的简单框架讨论公司的资本结构。而现实世界中，每一种和“理想市场”相违背的条件都有可能对企业投融资决策造成影响，以MM定理作为参照点，我们可以精确地量化估算这种影响在最终企业价值上的体现——这些影响正是所有公司投资决策都要理解和考虑的问题。以此为起点，对公司的投融资决策的研究开始进入一个有体系的时期，因此，这条定理被视为是现代公司金融的开山之作。同时，基于无套利假设的分析框架也开始成为金融学研究中具有代表性的研究思路。</p>
</li>
<li><p>在1972年， 费雪·布莱克（Fischer Black）和迈伦·舒尔斯（Myron Scholes）合作的文章中提出了一种 <strong>基于无套利假设的模型为期权产品定价</strong>。某只股票的买入（卖出）期权就是指以某个固定的执行价格在一定的期限内买入（卖出）该证券的权利。无套利假设告诉我们，在一定的价格随机过程假设下，每一时刻都可通过股票和股票期权的适当组合对冲风险，使该组合变成无风险证券，从而就可得到期权价格与股票价格之间的一个偏微分方程。只要解出这个偏微分方程，期权的价格就得以确定。 ————第二次华尔街革命</p>
</li>
</ol>
<h2 id="宏观金融学——经济系的金融学"><a href="#宏观金融学——经济系的金融学" class="headerlink" title="宏观金融学——经济系的金融学"></a>宏观金融学——经济系的金融学</h2><pre><code>研究宏观的总量的金融问题的学问，比如货币的供求、银行的运营、利息决定、汇率变动，以及金融市场与经济增长经济危机等等。宏观金融学有时候也叫作“货币经济学”。
</code></pre><h3 id="历史大纪事：-1"><a href="#历史大纪事：-1" class="headerlink" title="历史大纪事："></a>历史大纪事：</h3><pre><code>1936年。就在这一年，凯恩斯出版了一本被称为“拯救了资本主义”的不朽著作——《就业、利息和货币通论》（The General Theory of Employment,Interest,and Money），现代宏观经济学就此产生。其中，凯恩斯关于货币供给调节、利率决定，以及汇率决定的理论被后来者不断延伸拓展，宏观金融学由此形成，其核心就是货币经济学
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/05/15/极简白话金融学/" data-id="ck7yku2ri000to5yriy1c4jv8" class="article-share-link">Compartir</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-吃透js中正则表达式" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/02/22/吃透js中正则表达式/" class="article-date">
  <time datetime="2019-02-22T02:29:33.000Z" itemprop="datePublished">2019-02-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/02/22/吃透js中正则表达式/">吃透js中正则表达式</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>我们在开发的过程中总会碰到一些需求需要做字符串匹配，当遇到一些稍微复杂一点的匹配规则时，如果我们对正则还不那么清晰,我们总是会去网上搜索一些现成的正则匹配，ctrl+c,ctrl+v。时间长了我们对这种修修补补的方式不厌其烦。那么今天就对正则表达式做足功夫，磨刀不误砍柴工，首先推荐一个学习正则的一个可视化的工具网址： <a href="https://regexper.com" target="_blank" rel="noopener">https://regexper.com</a>，输入正则规则即可生成匹配规则的流程图。了解并吃透正则会为我们以后开发节省很多时间和精力，一劳永逸。先从最基本的概念开始吧，let go!</p>
<h3 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h3><p>概念：有特殊含义的特殊字符，eg： * + ? $ ^ . | \ ( ) { } [ ]等</p>
<h4 id="通用含义元字符"><a href="#通用含义元字符" class="headerlink" title="通用含义元字符"></a>通用含义元字符</h4><p>在大部分语言语境中代表同一种含义，如下表：</p>
<table>
<thead>
<tr>
<th style="text-align:left">字符</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">\t</td>
<td style="text-align:left">水平制表符</td>
</tr>
<tr>
<td style="text-align:left">\v</td>
<td style="text-align:left">垂直制表符</td>
</tr>
<tr>
<td style="text-align:left">\n</td>
<td style="text-align:left">换行符</td>
</tr>
<tr>
<td style="text-align:left">\r</td>
<td style="text-align:left">回车符</td>
</tr>
<tr>
<td style="text-align:left">\0</td>
<td style="text-align:left">空字符</td>
</tr>
<tr>
<td style="text-align:left">\f</td>
<td style="text-align:left">换页符</td>
</tr>
<tr>
<td style="text-align:left">\cX</td>
<td style="text-align:left">Ctrl+X</td>
</tr>
</tbody>
</table>
<h4 id="其他含义元字符"><a href="#其他含义元字符" class="headerlink" title="其他含义元字符"></a>其他含义元字符</h4><h5 id="1-字符类"><a href="#1-字符类" class="headerlink" title="1. 字符类"></a>1. 字符类</h5><ul>
<li>我们可以使用元字符[]来构建一个简单的字符类</li>
<li>所谓的类是指符合某些特性的对象，一个泛指，而不是特指某个字符</li>
<li>表达式[abc]归为一类，表达式可以匹配这些类的字符<br><img src="https://user-gold-cdn.xitu.io/2019/2/22/1691537782c64cc4" alt=""><h5 id="2-字符类取反"><a href="#2-字符类取反" class="headerlink" title="2. 字符类取反"></a>2. 字符类取反</h5></li>
<li>我们可以使用元字符^来创建反向类/负向类</li>
<li>反向类的意思是不属于某个类的内容</li>
<li>表达式[^abc]表示不是字符a或b或c的内容<br><img src="https://user-gold-cdn.xitu.io/2019/2/22/169153777e9b7144" alt=""><h5 id="3-范围类"><a href="#3-范围类" class="headerlink" title="3. 范围类"></a>3. 范围类</h5></li>
<li>正则表达式还提供了范围类</li>
<li>我们使用[a-z]来连接两个字符表示从a到z的任意字符</li>
<li>这是个闭区间也就包含a和z本身<br><img src="https://user-gold-cdn.xitu.io/2019/2/22/1691537781734783" alt=""><h5 id="4-预定义类"><a href="#4-预定义类" class="headerlink" title="4. 预定义类"></a>4. 预定义类</h5></li>
<li>正则表达式提供了一些特殊字符表示自一组比较复杂的匹配规则，如下表：</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:left">字符</th>
<th style="text-align:left">等价</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">.</td>
<td style="text-align:left">[^\r\n]</td>
<td style="text-align:left">除了回车符和换行符之外的所有字符</td>
</tr>
<tr>
<td style="text-align:left">\d</td>
<td style="text-align:left">[0-9]</td>
<td style="text-align:left">数字字符</td>
</tr>
<tr>
<td style="text-align:left">\D</td>
<td style="text-align:left">[^0-9]</td>
<td style="text-align:left">非数字字符</td>
</tr>
<tr>
<td style="text-align:left">\s</td>
<td style="text-align:left">[\t\n\x0B\f\r]</td>
<td style="text-align:left">空白符</td>
</tr>
<tr>
<td style="text-align:left">\0</td>
<td style="text-align:left">[^\t\n\x0B\f\r]</td>
<td style="text-align:left">非空白符</td>
</tr>
<tr>
<td style="text-align:left">\w</td>
<td style="text-align:left">[a-zA-Z_0-9]</td>
<td style="text-align:left">单词字符(字母数字下划线)</td>
</tr>
<tr>
<td style="text-align:left">\W</td>
<td style="text-align:left">[^a-zA-Z_0-9]</td>
<td style="text-align:left">非单词字符</td>
</tr>
</tbody>
</table>
<h5 id="5-边界"><a href="#5-边界" class="headerlink" title="5. 边界"></a>5. 边界</h5><ul>
<li>正则表达式还提供了几个常用的边界匹配字符，如下表：</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:left">字符</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">^</td>
<td style="text-align:left">以xxx开始</td>
</tr>
<tr>
<td style="text-align:left">$</td>
<td style="text-align:left">以xxx结束</td>
</tr>
<tr>
<td style="text-align:left">\b</td>
<td style="text-align:left">单词边界</td>
</tr>
<tr>
<td style="text-align:left">\B</td>
<td style="text-align:left">非单词边界</td>
</tr>
</tbody>
</table>
<h5 id="6-量词"><a href="#6-量词" class="headerlink" title="6. 量词"></a>6. 量词</h5><table>
<thead>
<tr>
<th style="text-align:left">字符</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">?</td>
<td style="text-align:left">出现一次或0次（最多出现一次）</td>
</tr>
<tr>
<td style="text-align:left">+</td>
<td style="text-align:left">出现一次或多次（最少出现一次）</td>
</tr>
<tr>
<td style="text-align:left">*</td>
<td style="text-align:left">出现0次或多次（任意次）</td>
</tr>
<tr>
<td style="text-align:left">{n}</td>
<td style="text-align:left">出现n次</td>
</tr>
<tr>
<td style="text-align:left">{n, m}</td>
<td style="text-align:left">出现n到m次</td>
</tr>
<tr>
<td style="text-align:left">{n, }</td>
<td style="text-align:left">至少出现n次</td>
</tr>
</tbody>
</table>
<h3 id="js正则的贪婪模式和非贪婪模式"><a href="#js正则的贪婪模式和非贪婪模式" class="headerlink" title="js正则的贪婪模式和非贪婪模式"></a>js正则的贪婪模式和非贪婪模式</h3><ol>
<li><p>贪婪模式：\d{3,6}匹配数字3到6次，那么在匹配的过程中会尽可能多的的匹配。如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos;12345678&apos;.replace(/\d&#123;3,6&#125;/, &apos;X&apos;)  // &quot;X78&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>非贪婪模式：在量词后面加上 ? ,可以让正则表达式尽可能少的匹配，也就是非贪婪模式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos;12345678&apos;.replace(/\d&#123;3,6&#125;?/, &apos;X&apos;)  // &quot;X45678&quot;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h3><p>对一组正则规则加(),可以对正则进行分组，   </p>
<p>比如：对taoyouyou这组单词匹配三次<br>taoyouyou{3}<br><img src="https://gitee.com/taoyouyou/taoyouyou/raw/master/assets/photos/regex分组1.svg" alt=""><br>可视化后能看到只是最后一个单词u重复了3次，并没有达到目的<br>(taoyouyou){3}<br><img src="https://gitee.com/taoyouyou/taoyouyou/raw/master/assets/photos/regex分组2.svg" alt=""><br>taoyouyou重复了3次</p>
<h4 id="捕获组引用"><a href="#捕获组引用" class="headerlink" title="捕获组引用"></a>捕获组引用</h4><p>对字符串进行分组后，   </p>
<p>捕获组的编号是按照“(”出现的顺序，从左到右，从1开始进行编号的 。   </p>
<p>在replace方法中可以通过$number(number表示捕获组的编号)进行引用      </p>
<p>在js表达式中分组引用通过RegExp对象暴露出来，    </p>
<p>即通过RegExp.$number引用   </p>
<p>例如实现2019-02-22 =&gt; 02/22/2019的转化。<br><img src="https://gitee.com/taoyouyou/taoyouyou/raw/master/assets/photos/regex分组3.svg" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos;2019-02-22&apos;.replace(/(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/,&apos;$2/$3/$1&apos;)   //  &quot;02/22/2019&quot;</span><br></pre></td></tr></table></figure></p>
<h4 id="反向引用"><a href="#反向引用" class="headerlink" title="反向引用"></a>反向引用</h4><p>正则表达式中所定义的捕获的反向引用指的是 </p>
<blockquote>
<p>将捕获作为正则表达式中能够成功匹配术语时的候选字符串      </p>
</blockquote>
<p>这种术语表示法是在反斜杆后面加一个要引用的捕获数量。<br>捕获组捕获到的内容，不仅可以在正则表达式外部通过程序进行引用，也可以在正则表达式内部进行引用，这种引用方式就是反向引用。反向引用的作用通常是用来查找或限定重复、查找或限定指定标识配对出现等等。<br>例如:([a-z])\1{2}也就表达连续三个相同的小写字母。   </p>
<p><img src="https://gitee.com/taoyouyou/taoyouyou/raw/master/assets/photos/regex分组5.svg" alt=""></p>
<h4 id="忽略分组"><a href="#忽略分组" class="headerlink" title="忽略分组"></a>忽略分组</h4><p>不需要捕获某些分组只需要在分组内加 ?: 就可以了。<br>(?:taoyouyou).(ok)<br><img src="https://gitee.com/taoyouyou/taoyouyou/raw/master/assets/photos/regex分组4.svg" alt=""></p>
<h3 id="前瞻"><a href="#前瞻" class="headerlink" title="前瞻"></a>前瞻</h3><ul>
<li>正则表达式从文本头部向尾部解析，文本尾部方向称为 “前”</li>
<li>前瞻：正则表达式匹配到规则的时候，向前检查是否符合断言，后顾/后瞻方向相反</li>
<li>JavaScript不支持后顾</li>
<li>符合和不符合某项断言称为肯定/正向匹配和否定/负向匹配</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:left">名称</th>
<th style="text-align:left">正则</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">正向前瞻</td>
<td style="text-align:left">exp(?=assert)</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">负向前瞻</td>
<td style="text-align:left">exp(?!assert)</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">正向后顾</td>
<td style="text-align:left">exp(?&lt;=assert)</td>
<td style="text-align:left">JavaScript不支持</td>
</tr>
<tr>
<td style="text-align:left">负向后顾</td>
<td style="text-align:left">exp(?&lt;!assert)</td>
<td style="text-align:left">JavaScript不支持</td>
</tr>
</tbody>
</table>
<h3 id="正则对象属性"><a href="#正则对象属性" class="headerlink" title="正则对象属性"></a>正则对象属性</h3><ul>
<li>global: 是否全文匹配，默认false，匹配规则后面加g开启</li>
<li>ignoreCase: 是否大小写敏感， 默认false，匹配规则后面加i开启</li>
<li>multiline: 多行搜索， 默认false，匹配规则后面加m开启</li>
<li>lastIndex: 当前表达式匹配内容最后一个字符的下一个位置</li>
<li>source: 正则表达式的文本字符串<br>这几个属性都是只读属性<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">reg=/\d/gmi</span><br><span class="line">reg.global  // true</span><br><span class="line">reg.ignoreCase  // true</span><br><span class="line">reg.multiline  // true</span><br><span class="line">reg.lastIndex  // 0</span><br><span class="line">reg.source  // &quot;\d&quot;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="对象方法"><a href="#对象方法" class="headerlink" title="对象方法"></a>对象方法</h3><h4 id="1-正则test方法"><a href="#1-正则test方法" class="headerlink" title="1. 正则test方法"></a>1. 正则test方法</h4><p> RegExp.prototype.test(str)</p>
<ul>
<li>用于测试字符串参数中是否存在匹配正则表达式模式的字符串</li>
<li>如果存在则返回true，否则返回false   </li>
</ul>
<p>需要注意的是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var reg2=/\w/g;</span><br></pre></td></tr></table></figure></p>
<p>进行reg2.test(‘ab’)时，第三次会变成false<br>原因：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">while(reg2.test(&apos;ab&apos;))&#123;</span><br><span class="line">  console.log(reg2.lastIndex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>即进行test时，正则表达式的lastIndex会发生变化<br>输出：1  2    表示第一个匹配上了、第二个匹配上了</p>
<h4 id="2-正则exec方法"><a href="#2-正则exec方法" class="headerlink" title="2. 正则exec方法"></a>2. 正则exec方法</h4><p> RegExp.prototype.exec(str)</p>
<ul>
<li>使用正则表达式模式对字符串参数进行匹配搜索，并将更新全局对象属性以反映匹配结果</li>
<li>如果没有匹配则返回null,否则返回一个结果数组：<br>属性index(声明匹配文本的第一个字符的位置), input(存放被检索的字符串string)<br>数组本身: [与正则表达式相匹配的文本，与正则对象的第一个子表达式（分组）相匹配的文本， 与正则对象的第二个子表达式（分组）相匹配的文本，…… ]<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var reg3=/\d(\w)(\w)\d/;    // 非全局搜索只能匹配到第一个结果</span><br><span class="line">var reg4=/\d(\w)(\w)\d/g;   // 全局搜索匹配全文</span><br><span class="line">var ts = &apos;$1az2bb3cy4dd5ee&apos;</span><br><span class="line">var ret1= reg3.exec(ts)     // (3) [&quot;1az2&quot;, &quot;a&quot;, &quot;z&quot;, index: 1, input: &quot;$1az2bb3cy4dd5ee&quot;, groups: undefined]</span><br><span class="line">console.log(reg3.lastIndex+&apos;\t&apos;+ret1.index+&apos;\t&apos;+ret1.toString())</span><br><span class="line">// &quot;0 1 1az2, a, z&quot;</span><br><span class="line">while(ret2 = reg4.exec(ts))&#123;</span><br><span class="line">  console.log(reg4.lastIndex+&apos;\t&apos;+ret2.index+&apos;\t&apos;+ret2.toString())</span><br><span class="line">&#125;</span><br><span class="line">// &quot;5 1 1az2, a, z&quot;</span><br><span class="line">// &quot;11 7 1az2, a, z&quot;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="3-字符串对象search方法"><a href="#3-字符串对象search方法" class="headerlink" title="3. 字符串对象search方法"></a>3. 字符串对象search方法</h4><p> String.prototype.search(reg)</p>
<ul>
<li>search方法用于检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串</li>
<li>返回第一个匹配结果index，查不到返回-1</li>
<li>search()不执行全局匹配，它将忽略标志g, 并总是从字符串的开始进行检索</li>
</ul>
<h4 id="4-字符串对象match方法"><a href="#4-字符串对象match方法" class="headerlink" title="4. 字符串对象match方法"></a>4. 字符串对象match方法</h4><p> String.prototype.match(reg)</p>
<ul>
<li>match方法将检索字符串，以找到一个或多个与regexp相匹配的字符串</li>
<li>regexp是否具有标志g对结果影响很大<h5 id="非全局调用"><a href="#非全局调用" class="headerlink" title="非全局调用"></a>非全局调用</h5></li>
<li>返回数组的第一个元素存放的是匹配文本,而其余的元素存放的是与正则表达式的子表达式匹配的文本</li>
<li>除了常规的数组元素之外,返回的数组还含有2个对象属性：index声明匹配文本的起始字符在字符串的位置,input声明对stringObject的引用</li>
<li>全局调用的返回与正则表达式的exec方法相类似，即：[与正则表达式相匹配的文本，与正则对象的第一个子表达式（分组）相匹配的文本， 与正则对象的第二个子表达式（分组）相匹配的文本，…… ]，数组有index和input属性<h5 id="全局调用"><a href="#全局调用" class="headerlink" title="全局调用"></a>全局调用</h5></li>
<li>如果regexp具有标志g则match方法将执行全局检索,找到字符串中的所有匹配子字符串</li>
<li>没有找到任何匹配的子串,则返回null</li>
<li>如果找到了一个或多个匹配子串,则返回-一个数组</li>
<li>数组元素中存放的是字符串中所有的匹配子串,而且也没有index属性或input属性<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var reg3=/\d(\w)(\w)\d/;    // 非全局搜索只能匹配到第一个结果</span><br><span class="line">var reg4=/\d(\w)(\w)\d/g;   // 全局搜索匹配全文</span><br><span class="line">var ts = &apos;$1az2bb3cy4dd5ee&apos;</span><br><span class="line">var ret1= ts.match(reg3)   // (3) [&quot;1az2&quot;, &quot;a&quot;, &quot;z&quot;, index: 1, input: &quot;$1az2bb3cy4dd5ee&quot;, groups: undefined]   </span><br><span class="line">console.log(reg3.lastIndex+&apos;\t&apos;+ret1.index)  // 0, 1</span><br><span class="line">var ret2 = ts.match(reg4)  // (2) [&quot;1az2&quot;, &quot;3cy4&quot;]</span><br><span class="line">console.log(reg4.lastIndex+&apos;\t&apos;+ret2.index)   // 0 undefined</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="5-字符串对象split方法"><a href="#5-字符串对象split方法" class="headerlink" title="5. 字符串对象split方法"></a>5. 字符串对象split方法</h4><p>String.prototype.split(reg)</p>
<ul>
<li>我们经常使用split方法把字符串分割为字符数组<br>eg: ‘a,b,c,d’.split(‘,’); //[“a”, “b”, “c”, “d”]</li>
<li>在一些复杂的分割情况下我们可以使用正则表达式解决<br>eg: ‘alb2c3d’.split(/\d/; //[“a”, “b”, “c”, “d”]</li>
</ul>
<h4 id="6-字符串对象replace方法"><a href="#6-字符串对象replace方法" class="headerlink" title="6. 字符串对象replace方法"></a>6. 字符串对象replace方法</h4><p>String.prototype.replace</p>
<ul>
<li>String.prototype.replace(str, replaceStr)</li>
<li>String.prototype.replace(reg, replaceStr)</li>
<li>String.prototype.replace(reg, function)<br>function参数含义<br>function会在每次匹配替换的时候调用,有四个参数<br>1、匹配字符串<br>2、正则表达式分组内容,没有分组则没有该参数<br>3、匹配项在字符串中的index<br>4、原字符串<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&apos;a1b2c3d4e5&apos;.replace(/\d/g, function(match, index, origin)&#123;</span><br><span class="line">  return parseInt(match) + 1;</span><br><span class="line">&#125;)  // &quot;a2b3c4d5e6&quot;</span><br><span class="line"></span><br><span class="line">&apos;a1b2c3d4e5&apos;.replace(/(\d)(\w)(\d)/g, function(match, group1, group2, group3, index, origin)&#123;</span><br><span class="line">  console.log(match)</span><br><span class="line">  return group1 + group3;</span><br><span class="line">&#125;)  </span><br><span class="line">// 1b2</span><br><span class="line">// 3d4</span><br><span class="line">// &quot;a12c34e5&quot;</span><br></pre></td></tr></table></figure></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/02/22/吃透js中正则表达式/" data-id="ck7yku2rg000po5yr1a9io2r4" class="article-share-link">Compartir</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/正则表达式/">正则表达式</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-初探pupeteer——踩坑之旅" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/12/29/初探pupeteer——踩坑之旅/" class="article-date">
  <time datetime="2018-12-29T07:17:24.000Z" itemprop="datePublished">2018-12-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/12/29/初探pupeteer——踩坑之旅/">初探pupeteer——踩坑之旅</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="关于pupeteer"><a href="#关于pupeteer" class="headerlink" title="关于pupeteer"></a>关于pupeteer</h2><p>Puppeteer是一个Node库，它提供了一个高级API来控制DevTools协议上的Chrome或Chromium。 Puppeteer默认运行无头，但可以配置为运行完整（非无头）Chrome或Chromium。<br>简单的来说是一个集成在node环境之上的可以控制谷歌浏览器爬取数据的工具</p>
<p>您可以在浏览器中手动执行的大多数操作都可以使用Puppeteer完成！ 以下一些简单的应用场景：</p>
<ul>
<li>生成页面的屏幕截图和PDF。</li>
<li>抓取SPA（单页面应用程序）并生成预渲染内容（即“SSR”（服务器端渲染））。</li>
<li>自动化表单提交，UI测试，键盘输入等。</li>
<li>创建最新的自动化测试环境。 使用最新的JavaScript和浏览器功能直接在最新版本的Chrome中运行测试。</li>
<li>捕获站点的时间线跟踪，以帮助诊断性能问题。</li>
<li>测试Chrome扩展程序。</li>
</ul>
<h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><p>安装pupeteer之前需要node的环境支持。node版本需要大于v6.4.0，如要使用 async / await，只有 Node v7.6.0 或更高版本才支持；另外，安装 Puppeteer 时，它会下载最新版本的 Chromium（〜71Mb Mac，〜90Mb Linux，〜110Mb Win），保证与 API 协同工作。</p>
<p>确保node环境安装完成以后，使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm init</span><br></pre></td></tr></table></figure></p>
<p>初始化项目</p>
<ol>
<li>使用命令安装<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yarn add puppeteer</span><br><span class="line"># or &quot;npm i puppeteer&quot;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>可能会出现以下报错:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ERROR: Failed to download Chromium r515411! Set &quot;PUPPETEER_SKIP_CHROMIUM_DOWNLOA</span><br><span class="line">D&quot; env variable to skip download.</span><br></pre></td></tr></table></figure></p>
<p>是因为在执行安装的过程中需要执行install.js，这里会下载Chromium,官网建议是进行跳过，我们可以执行 —ignore-scripts 忽略这个js执行。也可以通过设置环境变量set PUPPETEER_SKIP_CHROMIUM_DOWNLOAD=1阻止下载 Chromium （因为封网，直接下载会失败）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">  env PUPPETEER_SKIP_CHROMIUM_DOWNLOAD=true npm i puppeteer -D</span><br><span class="line">// npm i --save puppeteer --ignore-scripts</span><br></pre></td></tr></table></figure></p>
<ol>
<li>手动下载Chromium<br>下载地址：<a href="https://download-chromium.appspot.com/" target="_blank" rel="noopener">https://download-chromium.appspot.com/</a> (需要梯子…)</li>
</ol>
<p>把下载刚刚下载的文件解压出来会有chrome-win32文件夹，把里面的文件拷贝到项目新建的chromium文件夹中</p>
<ol>
<li>新建index.js,代码如下<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const puppeteer = require(&apos;puppeteer&apos;);</span><br><span class="line"></span><br><span class="line">(async () =&gt; &#123;</span><br><span class="line">    const browser = await puppeteer.launch();</span><br><span class="line">    const page = await browser.newPage();</span><br><span class="line">    await page.goto(&apos;https://y.qq.com&apos;);</span><br><span class="line">    await page.screenshot(&#123;path: &apos;yqq.png&apos;&#125;);</span><br><span class="line">    browser.close();</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>在命令行运行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node index.js</span><br></pre></td></tr></table></figure></p>
<p>这时候可能出现以下错误：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(node:8672) UnhandledPromiseRejectionWarning: Unhandled promise rejection (rejec</span><br><span class="line">tion id: 1): AssertionError [ERR_ASSERTION]: Chromium revision is not downloaded</span><br><span class="line">. Run &quot;npm install&quot;</span><br><span class="line">(node:8672) [DEP0018] DeprecationWarning: Unhandled promise rejections are depre</span><br><span class="line">cated. In the future, promise rejections that are not handled will terminate the</span><br><span class="line"> Node.js process with a non-zero exit code.</span><br></pre></td></tr></table></figure></p>
<p>显示chromium未下载错误，因为chromium默认的下载路径是在node_modules/puppeteer/.local-chromium/目录，这时候我们的chromium是在项目根目录，所以需要配置指定路径，修改index.js文件()：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const puppeteer = require(&apos;puppeteer&apos;);</span><br><span class="line"></span><br><span class="line">(async () =&gt; &#123;</span><br><span class="line">      const browser = await puppeteer.launch(&#123;</span><br><span class="line">        executablePath: &apos;./chromium/chrome.exe&apos;,</span><br><span class="line">        headless: false</span><br><span class="line">      &#125;);</span><br><span class="line">      const page = await browser.newPage();</span><br><span class="line">      await page.goto(&apos;http://music.163.com/&apos;);</span><br><span class="line">      await page.screenshot(&#123;path: &apos;music.png&apos;&#125;);</span><br><span class="line">      browser.close();</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure></p>
<p>再次运行<br><code>node index.js</code></p>
<p>puppeteer launch参数说明：</p>
<ul>
<li>executablePath： 运行Chromium或Chrome可执行文件的路径</li>
<li>headless： 是否运行在浏览器headless模式，true为不打开浏览器执行，默认为true</li>
<li>timeout： 等待浏览器实例启动的最长时间（以毫秒为单位）。默认为30000（30秒）。通过0禁用超时</li>
<li>args： 传递给浏览器实例的其他参数</li>
</ul>
<p>更多参数请参照:<a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md" target="_blank" rel="noopener">官网</a><br>中文地址：<a href="https://zhaoqize.github.io/puppeteer-api-zh_CN/#/" target="_blank" rel="noopener"></a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/12/29/初探pupeteer——踩坑之旅/" data-id="ck7yku2rc000ko5yrkqo5fbot" class="article-share-link">Compartir</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/网页爬虫/">网页爬虫</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-字符串的模式匹配" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/14/字符串的模式匹配/" class="article-date">
  <time datetime="2018-11-14T03:55:35.000Z" itemprop="datePublished">2018-11-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/14/字符串的模式匹配/">字符串的模式匹配</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="模式匹配-pattern-matching"><a href="#模式匹配-pattern-matching" class="headerlink" title="模式匹配 (pattern matching)"></a>模式匹配 (pattern matching)</h3><p>  一个目标对象T字符串,P字符串在目标T中寻找一个给定的模式P的过程<br>  用给定的模式P，在目标字符串T中搜索与模式P全同的一个子串，并求出T中第一个和P全同匹配的子串（简称为”配串”）,返回其首字符位置<br>  <img src="https://gitee.com/taoyouyou/taoyouyou/raw/master/assets/photos/字符串的模式匹配.png" alt=""><br>  如图所示：为使模式P与目标T匹配，必须满足p0 p1 p2 … pm-1 = ti ti+1 ti+2 … ti+m-1</p>
<h2 id="朴素算法（穷举法）"><a href="#朴素算法（穷举法）" class="headerlink" title="朴素算法（穷举法）"></a>朴素算法（穷举法）</h2><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>  设T = t0t1, t2, …,tn-1， P = p0, p1, …, pm-1</p>
<ul>
<li>i为T中字符的下标，j为P中字符的下标 </li>
<li>匹配成功(p0 = ti , p1 = ti+1 , …,  pm-1 = ti+m-1 ) 即T.substr(i, m) == P.substr(0, m)</li>
<li>匹配失败(pj≠ti ) 时，将 P 右一位移再行比较</li>
<li>尝试所有的可能情况<h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3>方法一：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int FindPat_1(string S, string P, int startindex) &#123;  </span><br><span class="line">  int LastIndex = S.length() – P.length();                   // 两个字符串的模式长度差值</span><br><span class="line">  int count = P.length();    </span><br><span class="line">  if (LastIndex &lt; startindex)&#123;                               // 开始匹配位置startindex的值过大，匹配无法成功</span><br><span class="line">    return (-1);</span><br><span class="line">  &#125;</span><br><span class="line">  for (int g = startindex; g &lt;= LastIndex; g++)&#123;             // g为S的游标，用模式P和S第g位置子串比较，若失败则继续循环   </span><br><span class="line">    if (P == S.substr(g, count))</span><br><span class="line">      return  g;</span><br><span class="line">  &#125;     </span><br><span class="line">  return  (-1);                                              // 若for循环结束，则整个匹配失败，返回值为负</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>方法二：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">int FindPat_2(string T, string P, int  startindex)&#123;</span><br><span class="line">  int LastIndex = T.length() - P.length();</span><br><span class="line">  if  (LastIndex &lt; startindex) return (-1);              // 开始匹配位置startindex的值过大，匹配无法成功   </span><br><span class="line">  int i = startindex,   j = 0;                           // i 是指向T内部字符的游标，j 是指向P内部字符的游标   </span><br><span class="line">  while (i &lt; T.length()  &amp;&amp;  j &lt; P.length())&#123;   </span><br><span class="line">    if (P[j] == T[i]) &#123;</span><br><span class="line">      i++;  j++;                                         // 若P[j] == T[i],则继续向下比较</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      i = i - j + 1; j = 0;                              // 否则匹配的初始位置(i-j)右移一位 即：i=i-j+1</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  if ( j &gt;=  P.length())&#123;</span><br><span class="line">    return (i - j);                                      // 若匹配成功，则返回该T子串的开始位置</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    return -1;</span><br><span class="line">  &#125;                                                      // 若失败，函数返回值为负 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>方法三：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int FindPat_3(string T, string P, int startindex) &#123;</span><br><span class="line">  for (int g= startindex; g &lt;= T.length() - P.length(); g++) &#123; //g为T的游标，      </span><br><span class="line">    for (int j=0; ((j&lt;P.length()) &amp;&amp; (T[g+j]==P[j])) ; j++);   //j为p的游标，满足条件则继续比较P的下一位j++,否则跳出内层循环将匹配的起始位置+1；即g++</span><br><span class="line">    if (j == P.length())</span><br><span class="line">      return  g;</span><br><span class="line">  &#125;</span><br><span class="line">  return(-1);                                                  // for结束，或startindex值过大,则匹配失败  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="效率分析"><a href="#效率分析" class="headerlink" title="效率分析"></a>效率分析</h3><ol>
<li>第一种情况： 最坏情况<br>– 假定目标 T 的长度为 n，模式 P 长度为 m，m≤n  – 在最坏的情况下，每一次循环都不成功，则一共要进行比 较（n-m+1）次<br>– 每一次“相同匹配”比较所耗费的时间，是 P 和 T 逐个 字符比较的时间，最坏情况下，共 m 次<br>– 因此，整个算法的最坏时间开销估计为：O( m * n )</li>
<li><p>第二种情况：没找到匹配下的最佳情况<br>• 总是在第一个字符上不匹配<br>• 总比较次数： – n – m + 1<br>• 时间复杂度： – O(n)</p>
<h2 id="KMP算法-无回溯匹配"><a href="#KMP算法-无回溯匹配" class="headerlink" title="KMP算法(无回溯匹配)"></a>KMP算法(无回溯匹配)</h2><h3 id="算法思想-1"><a href="#算法思想-1" class="headerlink" title="算法思想"></a>算法思想</h3><p>匹配过程中，一旦pj和ti 比较不等时，即P.substr(1,j-1) == T.substr(i-j+1,j-1)但pj≠ ti<br>– 将p右移的k位，用P中pk和ti进行比较<br>– 显然有k &lt; j, 且不同的j, 其k 值不同<br>– k 值仅仅依赖于模式P 本身，而与目标对象T无关</p>
<p><img src="https://gitee.com/taoyouyou/taoyouyou/raw/master/assets/photos/KMP算法思想.png" alt=""><br><img src="https://gitee.com/taoyouyou/taoyouyou/raw/master/assets/photos/KMP算法思想2.png" alt=""></p>
<h3 id="算法实现-1"><a href="#算法实现-1" class="headerlink" title="算法实现"></a>算法实现</h3><h4 id="字符串的特征向量"><a href="#字符串的特征向量" class="headerlink" title="字符串的特征向量"></a>字符串的特征向量</h4><p>设模式P 由m 个字符组成，记为P  =  p0 p1 p2 p3……pm-1<br>令特征向量N 用来表示模式P 的字符分布特征，简称N 向量由m个特征数n0 …nm-1 整数组成，记为N ＝n0 n1 n2 n3……nm-1<br>N在很多文献中也称为next 数组，每个nj 对应next 数组中的元素next[j]</p>
</li>
</ol>
<p>构造方法<br>P第j 个位置的特征数nj，首尾串最长的k<br>– 首串：p0    p1              … pk-2  pk-1<br>– 尾串：pj-k  pj-k+1        … pj-2   pj-1<br> <img src="https://gitee.com/taoyouyou/taoyouyou/raw/master/assets/photos/特征向量构造方法.png" alt=""><br>例如：对于字符串 P = a  a  a  a  b   a   a  a   a   c<br>     p的特征向量N = -1  0  1  2  3   0   1  2  3   4<br> <img src="https://gitee.com/taoyouyou/taoyouyou/raw/master/assets/photos/KMP模式匹配示例.png" alt=""></p>
<h4 id="KMP模式匹配算法"><a href="#KMP模式匹配算法" class="headerlink" title="KMP模式匹配算法"></a>KMP模式匹配算法</h4> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">int KMPStrMatching(string T, string P,  int* N, int start)&#123;</span><br><span class="line">  int j= 0;                   // 模式的下标变量</span><br><span class="line">  int i = start;              // 目标的下标变量</span><br><span class="line">  int pLen= P.length( );      // 模式的长度</span><br><span class="line">  int tLen= T.length( );      // 目标的长度</span><br><span class="line">  if(tLen-start &lt; pLen)       // 若目标比模式短，匹配无法成功</span><br><span class="line">  return(-1);          </span><br><span class="line">  while( j &lt; pLen&amp;&amp;  i &lt; tLen) &#123;  // 反复比较，进行匹配</span><br><span class="line">    if(j == -1  ||  T[i] == P[j])   </span><br><span class="line">      i++,  j++;</span><br><span class="line">    else j = N[j];</span><br><span class="line">  &#125;</span><br><span class="line">  if(j &gt;= pLen)</span><br><span class="line">    return(i-pLen);            // 注意仔细算下标</span><br><span class="line">  else</span><br><span class="line">    return(-1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="字符串的特征向量N-——非优化版"><a href="#字符串的特征向量N-——非优化版" class="headerlink" title="字符串的特征向量N ——非优化版"></a>字符串的特征向量N ——非优化版</h4> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> int findNext(string P) &#123;</span><br><span class="line">   int j, k;</span><br><span class="line">   int m = P.length();       // m为模式P的长度</span><br><span class="line">   assert(m &gt; 0);                   // 若m＝0，退出</span><br><span class="line">   int* next = new int[m];            // 动态存储区开辟整数数组</span><br><span class="line">   assert(next != 0);               // 若开辟存储区域失败，退出</span><br><span class="line">   next[0] = -1;   </span><br><span class="line">   j = 0;  </span><br><span class="line">   k = -1;</span><br><span class="line">   while(j &lt; m-1) &#123;                 </span><br><span class="line">    while(k &gt;= 0 &amp;&amp; P[k] != P[j])    // 不等则采用KMP 自找首尾子串</span><br><span class="line">      k = next[k];                   // k 递归地向前找</span><br><span class="line">    j++; k++; next[j] = k;   </span><br><span class="line">  &#125;</span><br><span class="line">  return next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> <img src="https://gitee.com/taoyouyou/taoyouyou/raw/master/assets/photos/模式右滑j-k位.png" alt=""></p>
<p>如图：模式右滑j-k位后 p0 p1 …pk-1 = ti-k ti-k+1 … ti-1<br>对于最后一位pj!==ti, 若pk == pj则一定有 pk!== ti;造成一次冗余比较</p>
<h4 id="字符串的特征向量N-——优化版"><a href="#字符串的特征向量N-——优化版" class="headerlink" title="字符串的特征向量N ——优化版"></a>字符串的特征向量N ——优化版</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">int findNext(string P) &#123;</span><br><span class="line">  int j, k;</span><br><span class="line">  int m = P.length();               // m为模式P的长度</span><br><span class="line">  int* next = new int[m];           // 动态存储区开辟整数数组</span><br><span class="line">  next[0] = -1;   </span><br><span class="line">  j = 0;  </span><br><span class="line">  k = -1;</span><br><span class="line">  while(j &lt; m-1) &#123;                  // 若写成j &lt; m 会越界</span><br><span class="line">    while(k &gt;= 0 &amp;&amp; P[k] != P[j])&#123;  // 若不等，采用KMP 找首尾子串</span><br><span class="line">      k = next[k];                  // k 递归地向前找</span><br><span class="line">    &#125;             </span><br><span class="line">    j++;   k++; </span><br><span class="line">    if(P[k] == P[j])   </span><br><span class="line">      next[j] = next[k];           // 前面找k 值，没有受优化的影响</span><br><span class="line">    else</span><br><span class="line">      next[j] = k;                 // 取消if判断，则不优化</span><br><span class="line">  &#125;</span><br><span class="line">  return next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>next数组对比<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">序号j           0   1   2   3   4   5   6   7   8</span><br><span class="line"> P             a   b   c   a   a   b   a    b   c</span><br><span class="line"> k                 0   0   0   1   1   2    1   2        //非优化版</span><br><span class="line">pk==pj?            ≠   ≠   ==  ≠  ==   ≠   ==   ==</span><br><span class="line"> next[j]      -1   0   0  -1   1   0   2   0    0        //优化版</span><br></pre></td></tr></table></figure></p>
<h3 id="算法效率"><a href="#算法效率" class="headerlink" title="算法效率"></a>算法效率</h3><p>求特征数组的时间为O(m)<br>KMP算法的时间为O(n+m)</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/11/14/字符串的模式匹配/" data-id="ck7yku2re000mo5yra7s122kr" class="article-share-link">Compartir</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/KMP算法/">KMP算法</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/字符串的特征向量/">字符串的特征向量</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/朴素算法/">朴素算法</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-农夫过河算法实现" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/12/农夫过河算法实现/" class="article-date">
  <time datetime="2018-11-12T08:41:03.000Z" itemprop="datePublished">2018-11-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/12/农夫过河算法实现/">农夫过河算法实现</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>  一个农夫带着—只狼、一只羊和—棵白菜，身处河的南岸。他要把这些东西全部运到北岸。他面前只有一条小船，船只能容下他和—件物品，另外只有农夫才能撑船。如果农夫在场，则狼不能吃羊，羊不能吃白菜，否则狼会吃羊，羊会吃白菜，所以农夫不能留下羊和白菜自己离开，也不能留下狼和羊自己离开，而狼不吃白菜。请求出农夫将所有的东西运过河的方案。</p>
<h2 id="问题抽象"><a href="#问题抽象" class="headerlink" title="问题抽象"></a>问题抽象</h2><p>“人狼羊菜”乘船过河<br>只有人能撑船，船只有两个位置（包括人）<br>狼羊、羊菜不能在没有人时共处</p>
<h2 id="数据抽象"><a href="#数据抽象" class="headerlink" title="数据抽象"></a>数据抽象</h2><p>每个角色的位置进行描述<br>农夫、狼、菜和羊，四个目标各用一位（假定按照农夫、狼、白菜、羊次序），目标在起始岸位置：0，目标岸：1</p>
<p>确定每个角色位置的函数：  返回true则在目标岸， 返回false则在起始岸<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">bool farmer(int status)&#123;</span><br><span class="line">  return ((status &amp; 0x08) != 0);</span><br><span class="line">&#125;</span><br><span class="line">bool wolf(int status)&#123;</span><br><span class="line">  return ((status &amp;0x04)!= 0);</span><br><span class="line">&#125;</span><br><span class="line">bool cabbage(int status)&#123;</span><br><span class="line">  return((status &amp; 0x02) != 0);</span><br><span class="line">&#125;</span><br><span class="line">bool goat(int status)&#123;</span><br><span class="line">  return((status &amp; 0x01) != 0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>安全状态的判断<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">bool safe(intstatus)&#123;     // 返回true:安全，false:不安全</span><br><span class="line">  if((goat(status)==cabbage(status)) &amp;&amp; (goat(status)!=farmer(status)))</span><br><span class="line">    return(false);        // 羊吃白菜</span><br><span class="line">  if((goat(status)==wolf(status)) &amp;&amp; (goat(status)!=farmer(status)))</span><br><span class="line">    return(false);        // 狼吃羊return(true);</span><br><span class="line">&#125;// 其它状态为安全</span><br></pre></td></tr></table></figure></p>
<h2 id="算法抽象"><a href="#算法抽象" class="headerlink" title="算法抽象"></a>算法抽象</h2><p>  问题变为从状态0000（整数0）出发，寻找全部由安全状态构成的状态序列，以状态1111（整数15）为最终目标。</p>
<ul>
<li>状态序列中每个状态都可以从前一状态通过农夫（可以带一样东西）划船过河的动作到达。</li>
<li>序列中不能出现重复状态<h2 id="算法设计"><a href="#算法设计" class="headerlink" title="算法设计"></a>算法设计</h2></li>
<li>定义一个整数队列moveTo，它的每个元素表示一个可以安全到达的中间状态</li>
<li>还需要定义一个数据结构记录已被访问过的各个状态，以及已被发现的能够到达当前这个状态的路径</li>
<li>用顺序表route 的第i 个元素记录状态i是否已被访问过，若route[i] 已被访问过，则在这个顺序表元素中记入前驱状态值；-1表示未被访问，route 的大小（长度）为16<h2 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"> void solve() &#123;</span><br><span class="line">   int movers, i, location, newlocation;</span><br><span class="line">   vector&lt;int&gt; route(END+1, -1);  // 记录已考虑的状态路径</span><br><span class="line">   queue&lt;int&gt; moveTo;// 准备初值</span><br><span class="line">   moveTo.push(0x00);</span><br><span class="line">   route[0]=0;</span><br><span class="line">   while(!moveTo.empty() &amp;&amp; route[15] == -1) &#123;// 得到现在的状态</span><br><span class="line">    status = moveTo.front();</span><br><span class="line">    moveTo.pop();</span><br><span class="line">    for(movers = 1; movers &lt;= 8; movers &lt;&lt;= 1) &#123;// 农夫总是在移动，随农夫移动的也只能是在农夫同侧的东西</span><br><span class="line">      if (farmer(status)  == (bool)(status &amp; movers)) &#123;</span><br><span class="line">        newstatus = status ^ (0x08| movers);// 安全的，并且未考虑过的走法</span><br><span class="line">        if (safe(newstatus) &amp;&amp; (route[newstatus] == -1)) &#123;</span><br><span class="line">          route[newstatus] = status;moveTo.push(newstatus); </span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  // 反向打印出路径</span><br><span class="line">  if(route[15] != -1) &#123; </span><br><span class="line">    cout &lt;&lt;&quot;The reverse path is : “ &lt;&lt; endl;</span><br><span class="line">    for (intstatus = 15; status &gt;= 0; status = route[status]) &#123;</span><br><span class="line">      cout &lt;&lt; &quot;The status is : “ &lt;&lt; status &lt;&lt; endl;if(status == 0) </span><br><span class="line">      break;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">    cout &lt;&lt; &quot;No solution.“ &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>作为一名前端工程师，将以上逻辑使用了javascript实现了，全部代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line">class Queue &#123;</span><br><span class="line"></span><br><span class="line">  constructor() &#123;</span><br><span class="line">    // 定义一个数组来保存队列里面的元素</span><br><span class="line">    this.items = []</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 在队列尾部添加一个或者多个元素</span><br><span class="line">  enqueue(element) &#123; </span><br><span class="line">    this.items.push(element)</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  // 移除队列顶部的元素，并返回被移除的元素</span><br><span class="line">  dequeue() &#123;</span><br><span class="line">    return this.items.shift()</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  // 清空队列</span><br><span class="line">  remove() &#123;</span><br><span class="line">    this.items = []</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  // 返回队列顶部的元素，不对队列本身做修改</span><br><span class="line">  front() &#123;</span><br><span class="line">    return this.items[0]</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  // 判断队列是否为空</span><br><span class="line">  isEmpty() &#123;</span><br><span class="line">    return this.items.length === 0</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  // 返回队列里面元素的个数</span><br><span class="line">  length() &#123;</span><br><span class="line">    return this.item.length</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function farmer(status)&#123;</span><br><span class="line">  return ((status &amp; 0x08) != 0);</span><br><span class="line">&#125;</span><br><span class="line">function wolf(status)&#123;</span><br><span class="line">  return ((status &amp;0x04)!= 0);</span><br><span class="line">&#125;</span><br><span class="line">function cabbage(status)&#123;</span><br><span class="line">  return((status &amp; 0x02) != 0);</span><br><span class="line">&#125;</span><br><span class="line">function goat(status)&#123;</span><br><span class="line">  return((status &amp; 0x01) != 0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function safe(status)&#123;    // 返回true:安全，false:不安全</span><br><span class="line">  if((goat(status)==cabbage(status)) &amp;&amp; (goat(status)!=farmer(status))) // 羊吃白菜</span><br><span class="line">    return(false);        </span><br><span class="line">  if((goat(status)==wolf(status)) &amp;&amp; (goat(status)!=farmer(status))) // 狼吃羊</span><br><span class="line">    return(false);       </span><br><span class="line">  return(true);</span><br><span class="line">&#125;// 其它状态为安全</span><br><span class="line"></span><br><span class="line">(function ()&#123;</span><br><span class="line">  let movers;   // 移动的状态</span><br><span class="line">  let route = [];      // 存储对应的状态是否重复</span><br><span class="line">  let results = [],     // 输出结果</span><br><span class="line">      aftercross,</span><br><span class="line">      counter;     // 记录移动次数</span><br><span class="line">  for(let i =0; i&lt;16; i++)&#123;</span><br><span class="line">    route.push(-1);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  let moveTo = new Queue();  // 准备初值, 队列存储目标岸状态值</span><br><span class="line">  moveTo.enqueue(0x00);</span><br><span class="line">  route[0]=0;</span><br><span class="line">  while(!moveTo.isEmpty() &amp;&amp; route[15] == -1) &#123;  // 得到现在的状态</span><br><span class="line">    status = moveTo.front();</span><br><span class="line">    moveTo.dequeue();</span><br><span class="line">    </span><br><span class="line">    for(movers = 1; movers &lt;= 8; movers &lt;&lt;= 1) &#123;</span><br><span class="line">      if (farmer(status)  == Boolean(status &amp; movers)) &#123;// 随农夫移动的也只能是在农夫同侧的东西</span><br><span class="line">        newstatus = status ^ (0x08| movers); // 渡河后的情况</span><br><span class="line">        if (safe(newstatus) &amp;&amp; (route[newstatus] == -1)) &#123; // 安全的，并且未考虑过的走法</span><br><span class="line">          route[newstatus] = status;</span><br><span class="line">          moveTo.enqueue(newstatus);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if(route[15] != -1)&#123;</span><br><span class="line">    counter = 0;</span><br><span class="line">    for(status = 15; status &gt; 0; status = route[status])&#123;</span><br><span class="line">      results.push(status);</span><br><span class="line">      counter++;      </span><br><span class="line">      if(status == 0) return;</span><br><span class="line">    &#125;</span><br><span class="line">    console.log(results);</span><br><span class="line">    for(let i = 0; i&lt; counter; i++)&#123;</span><br><span class="line">      status= results[i];</span><br><span class="line">      aftercross = results[i+1];</span><br><span class="line">      if(status &amp; 0x08)&#123;</span><br><span class="line">        console.log(&quot;农夫从起始岸到目标岸:&quot;);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        console.log(&quot;农夫从目标岸到起始岸:&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      switch(status^aftercross)&#123;</span><br><span class="line">      case 12:</span><br><span class="line">        console.log(&quot;把狼带过河\n&quot;);</span><br><span class="line">        break;</span><br><span class="line">      case 10:</span><br><span class="line">        console.log(&quot;把菜带过河\n&quot;);</span><br><span class="line">        break;</span><br><span class="line">      case 9:</span><br><span class="line">        console.log(&quot;把羊带过河\n&quot;);</span><br><span class="line">        break;</span><br><span class="line">      default:</span><br><span class="line">        console.log(&quot;什么也不带\n&quot;);</span><br><span class="line">        break;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">      console.log(&quot;No solution for this problem.\n&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure></p>
<p>程序运行截图：<br><img src="https://gitee.com/taoyouyou/taoyouyou/raw/master/assets/photos/农夫过河实现.png" alt=""><br>源文件已上传到gitee代码片段： <a href="https://gitee.com/taoyouyou/codes/frxzgasyvpt71bjcq59d055" target="_blank" rel="noopener">https://gitee.com/taoyouyou/codes/frxzgasyvpt71bjcq59d055</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/11/12/农夫过河算法实现/" data-id="ck7yku2rh000ro5yr2monp3on" class="article-share-link">Compartir</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/数据结构/">数据结构</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/算法/">算法</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/队列/">队列</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-关于区块链中的Dapp" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/09/12/关于区块链中的Dapp/" class="article-date">
  <time datetime="2018-09-12T06:40:01.000Z" itemprop="datePublished">2018-09-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/09/12/关于区块链中的Dapp/">关于区块链中的Dapp</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>有人说2018年是区块链元年，区块链这个概念被越炒越火，也是之前一直知道比特币，知道最近才更多的了解到区块链的发展，知道了以太坊，智能合约，看到各种系名词RAM、DAPP、OTCBTC，今天主要讲的是Dapp</p>
<h2 id="什么是DAPP"><a href="#什么是DAPP" class="headerlink" title="什么是DAPP"></a>什么是DAPP</h2><p>  经过这几年移动互联网以及智能手机的普及，相信几乎所有人都知道了什么是APP(Application的简称)。 时间转眼迈入区块链时代， 一个新的名词DAPP(Decentralized Application)出现了。Dapp是Decentralized Application的简称，也就是分散式应用程序   </p>
<p>  只有当满足以下所有条件时，一个应用才可以称之为DAPP：</p>
<ul>
<li>应用必须完全开源、自治并且没有一个实体控制着该应用的大部分代币(Token)。该应用必须能够根据市场的反馈及技术要求进行升级，但是升级必须由应用的用户达成共识之后才可以进行；</li>
<li>应用的数据必须加密后存储在公开的区块链上；</li>
<li>应用必须拥有代币机制（可以使用已存在的代币或者新发行一种内置代币），矿工或者应用维护节点需要得到代币奖励；</li>
<li>应用代币的产生必须依据标准的加密算法，有价值的节点可以根据该算法获取应用的代币奖励。    </li>
</ul>
<p>  根据以上的标准，比特币、Asch都算是DAPP，<br>所以比特币是一个DAPP，Asch是一个DAPP，而基于Asch开发的<a href="http://link.zhihu.com/?target=https%3A//cctime.org" title="CCTIME" target="_blank" rel="noopener">CCTIME</a>。也是一个DAPP。不同的是，有些DAPP扮演了操作系统的角色(比如Ethereum、Asch)，基于这些平台可以很容易的开发出特定需求的DAPP，而有些DAPP(比如CCTIME)则是具体的应用。但它们都满足上面的标准。</p>
<h2 id="DAPP的核心要素"><a href="#DAPP的核心要素" class="headerlink" title="DAPP的核心要素"></a>DAPP的核心要素</h2><p>对于DAPP的开发，我们可以从零开始，重新创建一个完整的区块链系统并开发自己的应用，这相当于开发一个新的区块链项目，比较费事费力且对个人能力要求较高。对于一个普通的开发者来说，如果你想基于区块链开发自己的应用，那选择一个成熟的区块链应用开发平台就好了。这些平台一般会提供完善的接口以及开发工具，只需要操心业务逻辑及其实现就好了。关于区块链的底层部分，这些平台都会帮你处理好。 </p>
<ol>
<li>开发平台:<br> 目前最流行的开发平台是Ethereum：Ethereum是目前全球除了比特币以外第二大的区块链项目，它就像一台遍及全世界的分布式计算机，你只需要把你的应用部署在Ethereum上，应用的运行就可以由所有的Ethereum节点来保证了。应用的运行需要支付手续费(GAS)。缺点是需要学习一门新的语言Solidity。<br> 另外一个建议就是基于笔者所在团队开发的Asch(中文名叫做阿希)。只要掌握JavaScript，就可以基于Asch开发DAPP。 Asch采用的是侧链架构，每一个DAPP就是一套侧链。侧链可以有独立的区块链和节点网络。不同的DAPP之间互相不会影响。不同于Ethereum， Asch系统上DAPP数量的增加不会增加主链的负担，是一套更加先进的机制。</li>
<li>共识机制：<br> 共识机制决定了运行DAPP的各节点如何达成共识及获取奖励，<br> 目前最常用的共识机制有POW、POS以及DPOS等。POW依据计算资源分配奖励，目前Bitcoin、Ethereum都采用了这种机制(不过Ethereum后面可能要迁移到POS)。Asch采用的是经过PBFT优化后的DPOS机制，核心系统是由 101 个委托人节点组成，委托人是被社区选举的可信账户，得票最高的 101 个委托人负责生产区块。得票排名未进入前 101 名的账户被称为候选人，当他们将来获得足够多的选票并进入前 101 名后，将成为正式的委托人。基于阿希开发的DAPP默认采用这种共识机制，不过开发者可以自己修改并决定使用哪种共识机制。</li>
<li>代币分发:<br> 一般DAPP都会内置代币(Token), 而想让更多用户参与到DAPP的维护与使用中的话，就需要考虑好如何把代币分发到用户手中。<br> 目前最常见的有以下几种方案：<ul>
<li>挖矿：以Bitcoin为例，任何拥有计算资源的人都可以加入到Bitcoin的挖矿中来，通过挖矿奖励来获取新的Bitcoin。</li>
<li>ICO: 可以简单理解为众筹。通过收集市面上已经成熟的其他代币，根据一定比例兑换为本DAPP内的代币来完成。Ethereum就是按照 1BTC/2000ETH的比例通过ICO众筹到了很多BTC作为起始资金。这种分发方式在国内已被禁止。</li>
<li>空投： 将代币免费分发到用户手中。持有其他代币的用户只需要完成一个简单的绑定流程，就可以得到代币。最近的案例有CCTIME空投，具体方式可参考<a href="CCTime 加密货币时讯">CCTIME官网</a>。</li>
<li>私募：这个就跟找投资一样，依个人能力而定了。</li>
</ul>
</li>
</ol>
<h2 id="DAPP的生命周期"><a href="#DAPP的生命周期" class="headerlink" title="DAPP的生命周期"></a>DAPP的生命周期</h2><p>一个DAPP的生命周期主要分为三部分：</p>
<ol>
<li>撰写白皮书白皮书描述了DAPP的技术原理、要解决的问题以及特点等。社区对白皮书的反馈可以添加到后期的更新中。</li>
<li>分发代币可以采用上一章节描述的代币分发机制的一种。</li>
<li>开发DAPP，逐步进化完善在DAPP发布之后，如果该DAPP走向了一个健康发展的道路，可以期望会有越来越多掌握各种技能的用户加入到社区，一起维护DAPP的发展。DAPP的发展交由社区整体进行运营、更新。无论是比特币还是比特股，早期开发者所起到的作用已经越来越小，去中心化的社区已经可以推动这些项目的继续发展。</li>
</ol>
<h2 id="为什么需要DAPP开发"><a href="#为什么需要DAPP开发" class="headerlink" title="为什么需要DAPP开发"></a>为什么需要DAPP开发</h2><p>目前社会对于dapp开发的关注还刚刚开始，市面上还难以看到流行的DAPP应用。但是随着区块链技术的发展，传统的C/S模式可能会被颠覆，开发者也不用再去买云服务器部署自己的应用。有了区块链开发平台，开发者可以很容易的把应用部署到区块链上，这是一个基于全球服务器，7*24不间断服务的应用平台。另外由于DAPP代币机制的存在，开发者可以很容易的基于代币获得价值回报。相信在不久的将来，DAPP会超越传统APP，在人们的社会生活中扮演越来越重要的角色。</p>
<p>此文仅用于学习，原文转载自<a href="https://zhuanlan.zhihu.com/p/31578996" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/31578996</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/09/12/关于区块链中的Dapp/" data-id="ck7yku2rb000ho5yrmtk9jcom" class="article-share-link">Compartir</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/区块链/">区块链</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-独立ip划分虚拟子服务器" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/08/22/独立ip划分虚拟子服务器/" class="article-date">
  <time datetime="2018-08-22T07:13:02.000Z" itemprop="datePublished">2018-08-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/22/独立ip划分虚拟子服务器/">独立ip划分虚拟子服务器</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Linux上面的虚拟主机配置"><a href="#Linux上面的虚拟主机配置" class="headerlink" title="Linux上面的虚拟主机配置"></a>Linux上面的虚拟主机配置</h1><p>一、 查看服务器ip:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">ifconfig</span><br><span class="line">eth0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 172.16.220.40  netmask 255.255.240.0  broadcast 172.16.223.255</span><br><span class="line">        ether 00:16:3e:0e:06:b1  txqueuelen 1000  (Ethernet)</span><br><span class="line">        RX packets 432  bytes 75118 (73.3 KiB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 536  bytes 63372 (61.8 KiB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536</span><br><span class="line">        inet 127.0.0.1  netmask 255.0.0.0</span><br><span class="line">        loop  txqueuelen 1  (Local Loopback)</span><br><span class="line">        RX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br></pre></td></tr></table></figure></p>
<p>二、 修改ip为指定ip：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig eth0 172.16.1.9 net mask 255.255.0</span><br></pre></td></tr></table></figure></p>
<p>修改成功后再使用ifconfig可以看到ip已经成功改成指定ip了</p>
<p>三、分配第一个ip地址：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig eth0:1 172.16.1.5 broadcast 172.16.223.255 netmask 255.255.255.0        // broadcast为主ip的broadcast地址，netmask为255.255.255.0</span><br></pre></td></tr></table></figure></p>
<p>分配第n个ip由此类推， 如ifconfig eth0:2 … //分配第二个虚拟ip<br>配置成功后查看ifconfig:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">eth0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 172.16.1.9  netmask 255.255.240.0  broadcast 172.16.223.255</span><br><span class="line">        ether 00:16:3e:0e:06:b1  txqueuelen 1000  (Ethernet)</span><br><span class="line">        RX packets 655  bytes 142527 (139.1 KiB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 798  bytes 106958 (104.4 KiB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">eth0:1: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 172.16.1.5  netmask 255.255.255.0  broadcast 172.16.223.255</span><br><span class="line">        ether 00:16:3e:0e:06:b1  txqueuelen 1000  (Ethernet)</span><br><span class="line"></span><br><span class="line">lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536</span><br><span class="line">        inet 127.0.0.1  netmask 255.0.0.0</span><br><span class="line">        loop  txqueuelen 1  (Local Loopback)</span><br><span class="line">        RX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br></pre></td></tr></table></figure></p>
<p>可以看到虚拟ip已经成功分配</p>
<h1 id="Nginx虚拟主机的配置"><a href="#Nginx虚拟主机的配置" class="headerlink" title="Nginx虚拟主机的配置"></a>Nginx虚拟主机的配置</h1><p>也就是将我们刚刚配置的虚拟ip地址跟我们的虚拟主机绑定<br>一、 配置虚拟主机的nginx文件<br>nginx默认配置文件在/etc/nginx/nginx.conf下，一般轻易不做修改，我们在/etc/nginx目录下新建xnzj.conf作为虚拟主机的配置文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /etc/nginx</span><br><span class="line">vi xnzj.conf</span><br></pre></td></tr></table></figure></p>
<p>输入以下内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">user nginx;</span><br><span class="line">worker_processes auto;</span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections 1024;   // 设置最大连接数</span><br><span class="line">&#125;</span><br><span class="line">http &#123;</span><br><span class="line">    server &#123;</span><br><span class="line">        listen       172.16.1.5:81;    // 监听的ip</span><br><span class="line">        access_log  /var/log/nginx/server2/access.log  combined;  //配置日志文件</span><br><span class="line">        server_name  172.16.1.5;</span><br><span class="line">      </span><br><span class="line">        location / &#123;</span><br><span class="line">          index  index.html  index.htm;            // 监听的文件</span><br><span class="line">          root         /data/server2;              // 监听的文件目录</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>二、 配置好nginx文件后我们需要在对应目录下新建日志文件和项目启动文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cd /var/log/nginx/server2/</span><br><span class="line">touch access.log        //新建日志文件</span><br><span class="line">cd /data</span><br><span class="line">mkdir server2</span><br><span class="line">touch index.html  </span><br><span class="line">vi index.html    // vim模式下编辑index文件，仅作测试</span><br></pre></td></tr></table></figure></p>
<p>三、将xnzj.conf作为配置文件启动nginx服务<br>先关闭现有的nginx服务<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ps -ef|grep nginx   // 查看nginx进程占用的端口号</span><br><span class="line">root      1087  1053  0 14:53 pts/0    00:00:00 grep --color=auto nginx  </span><br><span class="line">kill -QUIT 1053    // 杀死nginx进程</span><br><span class="line">nginx -c /etc/nginx/xnzj.conf    // 将xnzj.conf作为配置文件启动nginx服务</span><br></pre></td></tr></table></figure></p>
<p>大功告成<br>完成上面工作之后如果访问172.16.1.5:81会自动转为访问data/server2/index.html了</p>
<p>四、 推荐一个命令行下的web浏览器工具links</p>
<ul>
<li>Links是一个运行在命令行模式下的Web浏览器，只能查看字符。Links的官网是Click here。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum install links   // 可以通过yum工具安装links</span><br><span class="line">links 172.16.1.5:81    //安装完成后可以访问网址或者IP地址就可以看到刚才配置的网页内容</span><br></pre></td></tr></table></figure>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/08/22/独立ip划分虚拟子服务器/" data-id="ck7yku2r8000eo5yryyf7qb8l" class="article-share-link">Compartir</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CentOS/">CentOS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Nginx/">Nginx</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-centos独立服务器划分虚拟服务" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/08/20/centos独立服务器划分虚拟服务/" class="article-date">
  <time datetime="2018-08-20T08:27:47.000Z" itemprop="datePublished">2018-08-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/20/centos独立服务器划分虚拟服务/">Centos搭建node项目</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="node环境安装和配置"><a href="#node环境安装和配置" class="headerlink" title="node环境安装和配置"></a>node环境安装和配置</h1><ol>
<li>下载并安装 Node.js<br>下载最新的稳定版 v6.10.3 到本地:<br><code>wget https://nodejs.org/dist/v8.11.4/node-v8.11.4-linux-x64.tar.xz</code><br>下载完成后, 将其解压:<br><code>tar xvJf node-v6.10.3-linux-x64.tar.xz</code><br>将解压的 Node.js 目录移动到 /usr/local 目录下:<br><code>mv node-v6.10.3-linux-x64 /usr/local/node-v6</code><br>配置 node 软链接到 /bin 目录:<br><code>ln -s /usr/local/node-v6/bin/node /bin/node</code></li>
<li>配置和使用 npm<br>下载 node 的压缩包中已经包含了 npm , 我们只需要将其软链接到 bin 目录下即可:<br><code>ln -s /usr/local/node-v6/bin/npm /bin/npm</code><br>配置环境变量:<br>将 /usr/local/node-v6/bin 目录添加到 $PATH 环境变量中可以方便地使用通过 npm 全局安装的第三方工具<br><code>echo &#39;export PATH=/usr/local/node-v6/bin:$PATH&#39; &gt;&gt; /etc/profile</code><br>生效环境变量:<br><code>source /etc/profile</code><br>通过 npm 安装进程管理模块 forever:<br><code>npm install forever -g</code><h1 id="vscode配置ftp-sync插件同步代码到服务器"><a href="#vscode配置ftp-sync插件同步代码到服务器" class="headerlink" title="vscode配置ftp-sync插件同步代码到服务器"></a>vscode配置ftp-sync插件同步代码到服务器</h1></li>
<li>Ctrl + Shift + P调出命令模式， &gt;ext install 安装扩展     </li>
<li>搜索ftp-sync插件，安装，等待安装成功后点击冲击那加载插件</li>
<li>Ctrl + Shift + P调出命令模式，输入命令Ftp-sync:Init</li>
<li><p>配置服务器远程连接文件（项目根目录下.vscode/ftp-sync.json）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">    &#123;</span><br><span class="line">    &quot;remotePath&quot;: &quot;./&quot;,   // 远程服务器路径</span><br><span class="line">    &quot;host&quot;: &quot;host&quot;,       // 服务器地址</span><br><span class="line">    &quot;username&quot;: &quot;username&quot;,    // 用户名</span><br><span class="line">    &quot;password&quot;: &quot;password&quot;,    // 密码</span><br><span class="line">    &quot;port&quot;: 21,                // 端口号</span><br><span class="line">    &quot;secure&quot;: false,        </span><br><span class="line">    &quot;protocol&quot;: &quot;ftp&quot;,         // 采用的协议</span><br><span class="line">    &quot;uploadOnSave&quot;: false,</span><br><span class="line">    &quot;passive&quot;: false,</span><br><span class="line">    &quot;debug&quot;: false,</span><br><span class="line">    &quot;privateKeyPath&quot;: null,</span><br><span class="line">    &quot;passphrase&quot;: null,</span><br><span class="line">    &quot;ignore&quot;: [</span><br><span class="line">        &quot;\\.vscode&quot;,</span><br><span class="line">        &quot;\\.git&quot;,</span><br><span class="line">        &quot;\\.DS_Store&quot;</span><br><span class="line">    ],</span><br><span class="line">    &quot;generatedFiles&quot;: &#123;</span><br><span class="line">        &quot;uploadOnSave&quot;: false,</span><br><span class="line">        &quot;extensionsToInclude&quot;: [],</span><br><span class="line">        &quot;path&quot;: &quot;&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置完成后在命令模式下输入Ftp-sync: Local to Remote,同步本地到远程；Ftp-sync: Remote to Local同步远程到本地<br>因为在上一篇笔记中配置了nginx以及反向代理。在项目部署到服务器后在项目目录下启动服务后即可通过域名访问</p>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/08/20/centos独立服务器划分虚拟服务/" data-id="ck7yku2ra000go5yrgnpbfty8" class="article-share-link">Compartir</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CentOS/">CentOS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Nginx/">Nginx</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/node/">node</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Siguiente &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categorías</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/web开发/">web开发</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/CentOS/">CentOS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/KMP算法/">KMP算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Nginx/">Nginx</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/">git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo/">hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/http/">http</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/https/">https</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mongodb/">mongodb</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/node/">node</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/web/">web</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/web开发/">web开发</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/区块链/">区块链</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/字符串的特征向量/">字符串的特征向量</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据结构/">数据结构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/朴素算法/">朴素算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/正则表达式/">正则表达式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/算法/">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/网页爬虫/">网页爬虫</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/队列/">队列</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Nube de Tags</h3>
    <div class="widget tagcloud">
      <a href="/tags/CentOS/" style="font-size: 20px;">CentOS</a> <a href="/tags/KMP算法/" style="font-size: 10px;">KMP算法</a> <a href="/tags/Nginx/" style="font-size: 20px;">Nginx</a> <a href="/tags/git/" style="font-size: 15px;">git</a> <a href="/tags/hexo/" style="font-size: 10px;">hexo</a> <a href="/tags/http/" style="font-size: 10px;">http</a> <a href="/tags/https/" style="font-size: 10px;">https</a> <a href="/tags/mongodb/" style="font-size: 10px;">mongodb</a> <a href="/tags/node/" style="font-size: 10px;">node</a> <a href="/tags/web/" style="font-size: 10px;">web</a> <a href="/tags/web开发/" style="font-size: 10px;">web开发</a> <a href="/tags/区块链/" style="font-size: 10px;">区块链</a> <a href="/tags/字符串的特征向量/" style="font-size: 10px;">字符串的特征向量</a> <a href="/tags/数据结构/" style="font-size: 10px;">数据结构</a> <a href="/tags/朴素算法/" style="font-size: 10px;">朴素算法</a> <a href="/tags/正则表达式/" style="font-size: 10px;">正则表达式</a> <a href="/tags/算法/" style="font-size: 10px;">算法</a> <a href="/tags/网页爬虫/" style="font-size: 10px;">网页爬虫</a> <a href="/tags/队列/" style="font-size: 10px;">队列</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archivos</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">三月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">六月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">五月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">二月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">十二月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">十一月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">九月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">八月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">七月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">三月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">二月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">十一月 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Posts recientes</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/03/19/如何用hexo搭出自己的博客系统/">如何用hexo搭出自己的博客系统</a>
          </li>
        
          <li>
            <a href="/2019/06/21/如何使用ESLint-Prettier来统一我们的前端代码风格/">如何使用ESLint + Prettier来统一我们的前端代码风格</a>
          </li>
        
          <li>
            <a href="/2019/05/15/极简白话金融学/">极简白话金融学</a>
          </li>
        
          <li>
            <a href="/2019/02/22/吃透js中正则表达式/">吃透js中正则表达式</a>
          </li>
        
          <li>
            <a href="/2018/12/29/初探pupeteer——踩坑之旅/">初探pupeteer——踩坑之旅</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 taoyouyou<br>
      Construido por <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>